Today marked the beginning of the coding portion of App Academy’s 12 week curriculum. The day began with a quick lecture on program logistics, rules, and a breakdown of pair programming. We were then assigned a pairing partner, and without any further adieu, we began today’s projects. The smaller assignments involved designing our own version of several Enumberable methods and various iteration methods. For the most part, these felt like a tool by which to introduce everyone to pair programming, as the coding element was relatively straightforward. The real challenge was adapting to an entirely new coding process– in particular, having to communicate your thought process to someone else and accept that there are not only multiple ways to approach the same problem, but that each solution is not always equal, and most important that your version of said solution might not be the best one of go forward with. Up until now, I sort of approached coding problems the same way: consider what is being asked, conceptualize any series of logical steps to arrive at the sought solution, and proceed on that path. Short of some rampant bug, it was rare that I would change much to the “big picture” as I progressed through the challenge. Not only did pair programming challenge this single-view mentality, but having a partner that is somewhat reliant on your participation makes it a lot easier to focus on the task at hand. No more hourly 5 minute-turn 10 minute breaks, and honestly, the entire day just flew by, and never did I find it difficult to maintain focus. The big project was to design from the ground up (and no rspec!) a program that would host a game of Ghost (two or more players have to take turns spelling a word, letter by letter, until one player actually completes a full word. The catch is that you must propose a letter that actually yields the possibility of reaching a full word; you just never want to be the player to spell it out completely). We began by mapping out the various classes and methods that we would have to create. We settled on three classes (Game, HumanPlayer, and ComputerPlayer), and we began with the computer player in particular, as that would set the tone for everything else. Essentially, the computer player would take in the word fragment thus far reached by combining all letters provided by all players, go through the provided dictionary and eliminate all words that did not begin with that fragment, and then pick a random word that was still available. It would then “say” the next letter in that word, so long as that in itself didn’t spell out a complete word. Only if there is one possible word will the computer begrudgingly lose by spelling it out. After we nailed down the ComputerPlayer, which took a bit, the rest went pretty smoothly. Our final step involved modifying the program to allow for more than two players to play simultaneously, and upon “losing”, that player would be knocked out, the game would then restart, and the ultimate winner would be the last man/woman/computer standing. The next 10 minutes or so was spent enjoying our program play itself in ghost: we created “Fred1”, “Fred2”, etc (up to “Fred10”) and watched as they took turns spelling out really obscure words until one was finally forced to spell a word. My partner and I would bet on which Fred would prevail in the end, and for some reason, “Fred6” seemed to be the strongest competitor, winning 4 of the 20 matches we had them play. We were particularly disturbed when Fred6 knocked out Fred4 by having the latter spell “Fuhrer.” Overall, I had a great day. It was difficult, but incredibly engaging and I look forward to tomorrow. It’s 11:35, and outside of walking to and from my apartment, I’ve been in front of a computer since 8:30am. And I oddly feel really good. Today began with a lecture–as I expect most days will–which went over yesterday’s projects and the reading assignments from the night before, largely in a Q&A format. Probably the most interesting take-away from this morning was realizing how little I understood about how references are handled, especially when populating empty hashes with default values, or creating 2-d arrays (and, again, populating them with default values). I feel like I have a pretty good grasp on it now, but it is still something that will surely creep back into my code in future programs. At least I’ll know what to look for. The pair programming today was awesome. We had to make a sudoku program as well as a matching game (or what we called, and I shall refer to it as such from now on, “MatchMaker”). Sudoku looked more interesting to us, so we began with that (although for future reference, projects should be attempted/completed in the order they appear in the day’s curriculum–thanks for the heads up, Maurice!). We finished the bulk of the program relatively early on in the day, but we became fixated on polishing it into not just a workable game, but one that was as visually satisfying as our current aptitude allowed. It involved utilizing a colorize gem to indicate in red which squares are “untouchable” (as they were set by the problem itself, which was read through a text file), and green for each square that you have placed a number on, and therefore can amend at your own pleasure. The program would only accept inputs that satisfied four conditions: that there were no other matching numbers in the same row, column, and respective 3x3 grid, and also that there was not already an untouchable number on that tile (i.e., placed by the computer). Every time a number is placed on a tile, the program would create a key for that tile in a hash, with the value being either :placed (indicating that the player placed it) or :original (if the it was originally set by the program). This not only allowed us to restrict placement of numbers on tiles with the value :original, but the program could easily test for a winning_position with a simple line: grid.values.count == 81 (a count of 81 values indicates that every coordinate is either :placed or :original, and since the game won’t allow you to make an illegal move, the only way to fill up the board is to solve it correctly). Beautifying the program took up more time than we expected, and so we had less time than we hoped to complete the MatchMaker game. MatchMaker is played on a board of X number of cards face down, and you flip two over to see if they match. If they do, keep them facing up, and if not, flip them back over to faced down. You play until all cards are facing up. To accomplish this, we created three classes (Game, Board, and Card). Card’s sole purpose was to create a card object, upon being called on. The name of said card would be randomly assigned among 14 options, each representing a different playing card (2-10,J,Q,K,A). Board would then initialize by creating a 2-d array, the dimensions of which are easily customizable, and then call upon the Card class to create a random card, upon which Board will push it into a “cards” array until the array consists of enough cards to fill half the available squares of the board. It will then duplicate each card (so every card has a match), and then populate the grid with the available cards. Once the board is created and populated (and this is done right at initialization with a clever method called “initiate” that handles the list of steps required to properly populate the board), the rest is handled by the Game class. We were unable to finish this to satisfaction by the time the day’s work was due, but we stayed behind for another few hours to finish it for our own satisfaction. In the end, it is not as visually pleasing as our Sudoku program, but it is fully runnable, and we were able to play several games without causing any errors (and we tried!). Overall, another very exciting experience that leaves me wanting for more. Gonna keep this short today, because recursive programming really kicked my a$$, it’s late, and I expect I won’t be able to sleep until I at least finish today’s projects (of which I can’t really estimate how long it will take). My pairing partner and I had a good start, but we really hit a brick wall when trying to write a merge_sort method (one that will run recursively). It’s frustrating because we can conceptualize the steps required for it to work, even thinking of it recursively, but we hit so many snags when trying to translate our ideas into working code. After class, I ended up writing my own version of a recursive sorting algorithm, and while it works “flawlessly”, it takes a long time to run after 6+ numbers (which surprised me!). Basically, my version checks an array for the first number and second number, and swaps them if the first one is bigger. Every time it swaps two numbers, it calls itself on the new array (with swapped numbers). If no swap is required, it compares the first number with the third number, and once it hits the end, it moves on to comparing the second number with the next, and so on. As before, if it ever has to swap two numbers, it runs itself again until it iterates over the entire array without ever swapping (in which case the array is completely sorted). Merge_sort operates somewhat similarly in that it swaps two numbers at a time until the concatenation of all numbers result in a sorted array, but I imagine it runs a hell of lot faster than my version. Anyway, just talking about it is bothering me now that I haven’t finished it. Off to bang my head against the wall for a few more hours. Another late night in the office. Today was a much smoother experience than yesterday. Besides the daily lecture in the morning, we were sent off to debug many different git-branches of of a sudoku game, throughout which the instructors meticulously sprinkled bugs all over the place. Some of the bugs were the obvious kinds–not closing a paranthesis, leaving out a keyword_end (or having too many)– the kinds you can recognize pretty quickly just from the error message. Others were less obvious: messing with the text file that would be used to generate the sudoku board, conflating variables within methods (like pos and val), and, my absolute favorite, calling upon undefined methods, and hoping you would glance over (or just accept) the fact that there is a method_missing method so that you wouldn’t get any error messages pointing you to the fact that there was no actual method by the name of whatever was (not) being called. My partner and I developed a great flow early on, and finished this exercise with plenty of time to work on the next: making a minesweeper game. Perhaps it was just an easier project than the past few days’, but whatever the reason, the entire process went incredibly smoothly. Despite experimenting with various means of populating a board with bombs, examining each tile to generate a number indicating bomb proximity, adding colors, recursively revealing empty tiles that are adjacent to each other (as well as the numbers adjacent to empty tiles since an empty tile indicates that it isn’t touching a bomb, and there is no reason to force the user to manually click on the surrounding tiles), all the way down to simple syntax errors, we couldn’t have spent more than 5 minutes debugging random errors. The final product is by far my proudest of this journey. I tinkered with it a bit more after class, really pushing colorize to its limits to try and make the “field” look like a field: black text on green, red bombs, colored numbers. I also changed how the grid is rendered so that each tile is separated by lines. The end result is definitely more flashy, but pretty clunky. I look forward to the day we learn about integrating our programs with some sort of user interface besides terminal. How else am I to share these with my friends who think the console is something that only came on Windows 98 machines!? Tomorrow we move onto Algorithms. I’ve been looking forward to these long before this program started, however I’m not sure how prepared I am after how difficult I found recursions. Only time will tell. Edit: Oh, and I love git (as well as github). I just know there are a thousand more useful features that I can’t yet begin to understand, but the simple ones we learned and used to day – init, config, add, commit, push– and the way it interacted with github, and allowed you to jump around different snapshots and branches of your code was really quite mindblowing. It’s incredible what programmers can do when creating something designed to make their lives easier. Friday has arrived, and it marks the first completed week of the program. Our focus is primarily on Monday’s assessment, which will be the first of seven “real” assessments along the way, with two fails (sub 90%) being grounds for dismissal. I did very well on the practice assessment given to us on the first day, but I am not feeling as confident about this upcoming one. It will cover not only the first three days of the program, but also the entire month of prep work, something that feels like it was forever ago. Hopefully the relative simplicity of the prep material (compared to what we are learning now) will make up for the fact that it won’t be as fresh. Today we covered algorithms, specifically two methods of searching through “trees” of nodes (and “leaves”): depth first search (DFS), and breadth first search (BFS). The former is more interesting to me, as it involves recursion, and (from my understanding) seems to be theoretically quicker to locate “nodes” that are much further away from the origin (or root) than a breadth first search. This is because DFS sort of races to the end of the tree, checks the last node, and then back tracks until it hits a node with unchecked sub-nodes (or “children”) and then continues down that path, until eventually it either finds the target, or ends up back at the root. BFS sort of searches horizontally, meaning that it is better for finding targets that are probably closer to the root, but will take longer to reach the end. It’s probably silly of me to think of the two like this, as we have yet to cover how different operations and algorithms might affect the speed at which your program will run, but conceptually, at least, this is how it makes sense to me. That said, I imagine I will be using breadth-first search more often – at least at first– because I am more comfortable operating within iterative loops than I am with recursion. And even without recursion, BFS is also a very elegant algorithm for searching through a tree of nodes. It essentially creates an array, with the sole element being the root node. It then starts a loop that will end only when the array is empty, and each iteration will add the children of whatever element is in the first spot. In the first case, this is the root (and therefor will add it’s children). It will then check the first element (here, the root) to see if it’s the target, and if not, it will remove it (or shift) it out of the array, and repeat the loop. Now, the first element in the array is the first child of the root. It will add its children to the end of the array, and then check to see if it is the target. This process will repeat until a target is found, in which case it returns the target (and leaves the loop), or the loop is empty, which means there is nothing left to search for, and then return nil. The actual code is no more than 5-6 lines, which is absolutely mind-blowing to me. Using this, we were able to create an algorithm that finds all possible move combinations (without checking for repeats) of a knight on a chess board, and then return the quickest path from any starting square to another. If you had asked me to guess how complicated/long this code would have been yesterday, I would have guessed hundreds of lines. I can’t recall off the top of my head, but it couldn’t have ended up being more than 60 lines after all was said and done. I can’t wait to implement this for more complicated purposes, eventually, perhaps, developing AI capable of challenging me in one of the games we are sure to create next week. Anyway, off to study for the assessment. Chess day has arrived! As an avid fan of chess, I’ve been looking forward to building my own chess program ever since I saw it on the curriculum. It’s also a two-day project, so we have plenty of time to make sure it gets the attention that it deserves. The day began with the dreaded (first) assessment. I spent the majority of my weekend studying for it, creating lists of every method and problem we’ve learned since our prep phase began until the third day of the program, and recreating the list over and over and over again until I was pretty much able to recreate each solution from memory. I did well on the test, but it came at the expense of my mental clarity thereafter (I still can’t stop thinking about merge_sort and binarysearch, even as I type this!). For future tests, I think I will place a higher priority on understanding the solutions on a higher level, instead of diving into the nitty gritty and just packing everything into my short-term recollection. On that front, I was a bit slow on the uptake today when beginning the chess program. Fortunately, my partner was very patient, and after a little head scratching on my part, things began to click very rapidly (a very exciting feeling that programming seems to produce quite a bit!). We set up the various classes, defined their relationships, and got through incorporating keyboard input into our program (so that the user can move a cursor around instead of just inputting coordinates). We made good progress in defining how the “sliding pieces” operate (bishops, rooks, and queens), and once we finish that, it shouldn’t be too hard to incorporate whatever code we produced there to the ‘stepping pieces’ (knight, king, and pawns). It’s incredible how exponentially complex a program gets as soon as you introduce even one more layer of complexity. I wonder if starting with checkers might have produced a smoother transition, but this program is trying to accomplish a lot in a short period of time, and so perhaps we just didn’t have the time. Random thought, that perhaps I’ll be able to investigate one day: If we were to finish the program, and set up two computer players capable only of making a random, valid move, how long, on average (if ever?) would it take until the game ends in checkmate? I suspect it is a lot longer than I think (for any chess-knoweledgable nitpickers out there, the program would obviously have to ignore certain rules like the 50-move rule. Anyway, very much looking forward to tomorrow to finish this project off, but for now, sleep is a bit higher up on my list of things I’m excited for. This will be a quick one. I have a 7 am appointment tomorrow (gotta schedule around classes now), and I stayed at a/A late tonight trying to finish the chess program (ha!). My partner and I left it at detecting a position in which a king is in check. It might not sound like a lot, but the journey to get there from where we were yesterday was quite a challenge. We hit everything from syntactic sugar issues to pass by reference errors (the latter taking us almost an hour at one point to track down!). It’s strange, but I never thought about how much would have to go into simply detecting check/checkmate. You essentially need to iterate over every piece on the board, aggragate the positions on the board that are “targeted” by a valid move, and then compare that list to the current location of a king. To calculate checkmate requires an additional step: king is already in check, and no pieces on the board have a valid move (a valid move being predicated on the notion that you can’t move if that move will result in your king being in check). Anyway, I spent more time than I should have trying to tackle this problem, and will pay for it tomorrow morning once I wake up with 5 or 6 hours of sleep (that once sounded like a pretty good amount, but with how intensive this program is, I need every second I can get). In the end, I have a somewhat robust system for detecting checkmate, however through various tests, I have located several (as of now unexplainable) exceptions. I think I’ll put this project on hold for now until I gain a better understanding of deciphering errors and perhaps gain a better grasp on “writing pretty code.” Anyway, I wish Phil and I could have had more time working on this one, but I’m beginning to learn that one of the bigger challenges of a/A is beginning a project knowing that you may not be able to finish it. Heck, even last week I spent several hours cleaning up my minesweeper game, only to probably never look at it again. Ah well. I really need to control my urge to complete every project. My partner and I made very good progress today with putting together a poker game. Our code was clean, the methods were readable, we had clever mechanisms to evaluate hands… putting everything together, it felt like we were really close by the time the clock struck 6. And so, without any sign of learning from my past, I thought I could just “finish it up” in no time. 6 PM turned 7, and 7 turned 8. Every time I thought I was one method away from tying things together, the need for another method arose, and with each new method, a few more bugs. I had already gotten past the purpose of the project, which was to implement test-driven development– I had arrived at the point where I wanted all players to actually be able to play against eachother, make bets when prompted, have the computer track bets, enforce rules, shuffle the deck and deal cards, remember who folded, raised, checked, or called. I wanted it to follow traditional poker rules (must make a raise at least as large as the last bet), tie breakers for hands of equal value (before looking at the composition of the hand), etc etc etc. Before I knew it, it was 11:45 PM, and I was still at App Academy, and I hadn’t started our homework yet. The program was sort of working, as I could actually play full rounds, but some of the rules I was trying to enforce were not being enforced correctly. Bets had to be at least the size the pot (instead of the last bet), meaning that most games would result in any player still in the hand being broke… It wasn’t pretty. And so I zipped the file, sent it to myself, and rushed home. I wonder if I’ll ever look at it again. Not sure. For now, it’s 1:30 am, and I still have about 20 minutes of reading left. Anyway, besides that experience, we learned a lot about utilizing RSpec in our own development process, and I was surprised by how much I liked it. It really gave my partner and me the time and incentive to gameplan our program before we started puking our ideas into Atom, and there is something psychologically satisfying about starting with all of these red tests, and then turning them green with a few lines of code. So I finally pulled myself away from the lab at 6. It was partially because I had almost 3 hours of video lectures to watch, along with standard reading/homework, but also because we are beginning to delve into the more theoretical side of programming (quantifying the efficiency of algorithms, inspecting how hashes work, etc), and while I am so far finding these topics very interesting, it’s a bit less “addictive” than trying to finish up a program that you are proud of. Anyway. Today we revisted a few old methods (two_sum, anagrams, etc) and experimented with different approaches to solve them. Doing so forced us to consider the time and space implications of each solution. The recurring theme seemed to be that for any method in which you used a double-nested each loop to compare items in an array with each other, you are looking at (O)n^2. For methods in which you are searching through a hash, you are looking at (0)1 (though creating the hash from an array is (0)N).. And for methods in which you are simply splitting an array until a single element is remaining (like bsearch), and/or merging it back together (mergesort), you are looking at (O)logN or (0)NlogN. I think. And the big scary one is algorithms in which you require steps by the magnitude of n factorial. I understand the purpose behind Big-O notation, and as for visualizing it, I try to imagine the number of steps it takes in relation to the input: binary search takes logN steps to search an array (N being the number of elements) since it just has to split the array logN times before it is guaranteed to find the target (by then at the latest), whereas mergesort requires logN steps to unwind the array, another logN steps to merge it back together, and each step involved in merging it back together requires N steps to sort the elements before it gets merged. As such, it can be somewhat notated as requiring logN(unwinding) + logN(winding) * N (sorting) steps, or logN + NlogN steps. And because Big-O notation is only concerned with the most significant level of complexity, we ignore the logN side of mergesort, and consider NlogN as the O number. Ok, so tomorrow we are going to create hash maps. Lately in my programs I’ve been trying to incorporate hashes more often, as I find they are incredibly useful to both store “attributes” their respective keys, but also you can often write more elegant code by acting upon the premise that calling the hash[key] without anything else returns a truthy value if that key exists. I’m not sure if it’s considered best practice, but now that it appears that hashes are actually faster than arrays in many respect to find keys, I am even more excited to use them whenever possible. Second week down! I can’t believe how fast this is all going. I had my reservations going into the program, at least concerning how miserable the next few months might be, but I was completely wrong. Had a great pairing experience on Friday. We had to create our own hashmap and eventually map it to a linked list to create our own LRU (Least Recently Used) Cache. What I thought would have been a highly technical, complicated and yet somewhat slow day was actually quite exciting. To create the Cache, we started with makign a hash function that would work on strings, arrays, and hashes. I was hoping we would be able to actually make our own hash function, but apparently that is very difficult, and something people spend their lives coming up with. So instead, we had to create an algorithm to consistently create string, arrays, and hashes into numbers, after which we would call Ruby’s built in Fixnum hash function on the resulting product. The challenges involved safeguarding against hash collisions by ensuring that, for example, an array of [‘a’, 'b’, 'c’] wouldn’t produce the same hash as a string 'abc’. My partner and I took advantage of Ruby’s .ord method for strings, and for arrays we broke down the array by element and called .ord on each element before joining the numbers and calling hash on it. If the array including any subarrays, we would recursively send them back into the hash function until the final (to be hashed) product was nothing but numbers. As for hashes, we iterated over the hash, created an array of all the key-value pairs, sorted them by they key, and then sent it through the array hash function. This way, all hashes would produce the same result, regardless of the 'order’ of the key/value pairs, so long as the keys and values where the same (respectively) This is in view of the fact that hashes aren’t supposed to contain any 'order’ except that Ruby has built in mechanisms for 'considering’ hash order (via a built in linked list). The imperfection with this approach is that an array of [[:a, 4],[:b, 2]] would create a hash collision with a hash of {a: 4, b: 2}. Oh well, it was a fun experiment. Once we had the hash function down, we would use that to send items into our hashmap by using their hash value % num_buckets (the amount of 'space’ in our hashmap) to determine the 'bucket’ they would go into. The purpose behind all of this is to have a method of being able to locate where they are, while removing any sort of bias towards a particular bucket. I’m getting very abstract now, and perhaps even mistaken in my understanding of how it works, but it is important that the items stored in your hash map are evenly distributed since you can search within the hashmap in constant time, but if a bucket has multiple items, then you need to iterate through it in (O)N time. Once we had that, we had to put everything together to make a cache, tha would essentially remember the last N items that it took, reordering them as they were 'revisited’ and ejecting the oldest item if a new item was introduced that would make the cache exceed its limit. For purposes of the exercise, the purpose of our cache was to save the value that would result from passing a number into a given block (for example, n**2), and so if you were to try to calculate it again while it was in the hash, it would simply retrieve the stored value instead of recalculating it. Obviosuly, squaring a number isn’t a huge issue for modern computers, but if it was something more complicated like an algorithm with (O)N^2 time complexity, with inputs constantly being sent in, then saving the value instead of recalculating it every time makes a lot of practical sense. Anyway, gotta go study for Monday’s assessment. Glad I got the reading out of the way in advance, because gosh it was dry.. Hopefully SQL proves to be somewhat more interesting than the introductory reading made it out to be. Pretty tired. Just got through four dense chapters going over the art of formulating queries, subqueries, joins, self joins, indexing, and constraints in SQL. This is probably the first time during this program that something hasn’t immediately captured my interest; and that is putting it lightly in the case of SQL. Hopefully when we integrate what we learn with Rails will it then be enough to keep things interesting. Anyway, took the second assessment this morning, and did well. As for the pair experience, had a very productive day with my partner. Considering we have just begun the first day of a new topic on the syllabus (SQL), he and I picked it up pretty quickly, finishing most of the assigned project. We both shared the sentiment that SQL is way more pedantic than it needs to be, and perhaps (and hopefully) we’ll be proven wrong one day. Ok, so SQL is slowly growing on me. Especially as we begin to use ORM and begin Rails alongside it. I do miss the days where our projects involved making ruby-based games, however. Today, my partner and I had to create a database of users, posts, questions, likes (the entirety of which reminded me a little of Reddit), and had to track their comments, questions, etc. I feel like I’ve been very fortunate with pair partners since I started, and today was no exception. What could have been a pretty long day was actually quite fun. We used Ruby to create models of each column and implemented many combinations of search queries to create methods that would return certain answers to common queries (like average number of ‘likes’ per question asked). It is really interesting how much is actually involved in something that I would have previously thought to be trivial. Besides that, there isn’t much to report on. Tonight should be the first time I get to bed before midnight (on a weeknight), and I intend on keeping to that, so this entry will be shorter than usual. Today we almost put SQL (at least directly) behind us. Not that it’s no longer a dirty word to me, but I’m still excited to venture deeper into Rails. My partner and I made great progress in today’s project, which was to make a working ‘URL Shortener.’ At first, the idea of the project amused me because the provided example was the appacademy website, and the resultant URL was only 2 characters shorter, but otherwise gibberish (P2efkASdf, etc), but for longer URLs, the utility becomes clearer. As for Rails itself, I find it absolutely incredible how forgiving it can be, and somewhat intuitive in the sense that it infers from what you tell it what you actually want. An example is creating a table of 'people,’ it knows to look for a 'person’ model as the singular object pointed to by the table. I also find ActiveRecord to be a lifesaver, insofar as it handles the tedious sides of SQL, only leaving the fun, puzzle-like queries to the user. Anyway, have a good amount of homework to complete, so I will leave today’s post at that. Gotta keep this short, but today: 1) Created a polling database, that linked users with polls, with questions, answers, responses, created the validaters to manage the relationship between each model, and the queries to count and maintain those relationships. 2) Solved the 8 Queens Problem during study hall, the solution of which I’m very proud of and will discuss in a later post. My version of the solution is able to solve up to a ~20x20 board with 20 queens, although it has only done so once (it utilizes a bit of… randomness in its methodology). Solved without any research of the challenge. 3) Very excited for trying out solo programming today, although I have also been very fortunate to work with so many amazing partners up until now. I’m sure I’ll be very excited to go back to pair programming half way through the day. Another week down. I can’t say enough how fast time is flying, and how much that stands in contrast with my expectations going in. Last week overall was probably the least exciting of the three so far, and that has been reflected in the length (or lack thereof) of my recent posts. And while this past week has been the ‘worst,’ Friday was by far the worst individual offender. It was solo day, meaning no pair partner. I thought this would mean a slightly more productive day since sometimes the act of swapping roles produces 'friction’ to the momentum of programming. Instead, Friday only highlighted some of the advantages offered by working in pairs. I found myself slightly more distracted as I worked throughout the day, and there were particular spots where I got stuck, yet the answer to my problem ended up being quite simple. In general, your pair partner would catch these and you would move on, while you would catch their moments of lapse. Without a pair, however, I made a few really silly mistakes, and took way too long tracking them down without a fresh pair of eyes. It’s interesting how you can stare at code and sort of subconsciously fill in errors of your own (knowing what you meant to type), and yet if you were looking at the same code of someone else, you would most likely have caught it immediately. Anyway, the project for Friday was to make our own version of ActiveRecord, which allows us to interact with a database through Rails. ActiveRecord is absolutely amazing, but I was less enthused to make my own version. Everything was guided by Rspecs, and I felt that the specs were a bit too narrow, and thus limited any sort of creative license or problem solving. It felt more like we were just following directions to make someone else’s version of ActiveRecord. That said, I did learn a lot, and am thankful for the project on the whole. This next week we will be learning HTML and CSS, a topic I’ve been excited about for a while. That aside, this weekend will be occupied by my studying for Monday’s assessment, which happens to be on the 4th of July (during which we still have class). A little bummed to be missing it this year, but it is what it is. Today we took our third assessment, which I believe marks the half way point in… assessment taking (there are rumors floating around that there is a seventh assessment, but until I see the practice file or some other indication of its existence, I will operate under the assumption that we are closer, rather than further, from the end of them). Don’t get me wrong, I think they’re an important step in forcing us to study, re-process, and hopefully solidify our understanding of the past week’s material, but it will also be nice to be able to use our weekends working on a project, going back in the curriculum and working on something we found difficult, etc, instead of cramming for a test. Today we bade farewell to SQL and we continue along rails and into CSS and HTML (sidenote – is it bid? bade? Google suggests that bade is acceptable, but I suddenly wonder why it sounded ok to me in the first place). My partner and I were tasked with the assignment to make an app that stores user contact information, and allows them to share it with other users. The project served multiple purposes – one, it was additional practice managing belongs_to and has_many relationships, but it was also the first time we really had to start a rails project from scratch, creating the appropriate controllers and models. Tomorrow, I imagine we will begin working with views. While I find the subject material to be a bit less stimulating than I did working directly in Ruby and creating programs, solving algorithms, etc, it is certainly exciting to learn the language that lets you eventually publish your work into an interactive online medium. Anyway, trying to get back into a pre-midnight sleep schedule, so off I go. Wow. Today covered a lot of material, and we certainly weren’t spared for homework (2.5 hours of video lectures, a good bit of reading, and several mini-projects). Today’s assignment involved making a quasi-clone of a now-defunct website 99dresses (using cats instead of dresses, of course). It was similar to our past assignments of working with migrations and associations, and validations, and constraints, and routes, and all that, except now we are beginning to add a face to our apps as we have to set up their corresponding view templates. Overall, the assignment was relatively straightforward at any given point, but the totality of putting everything together required keeping track of quite a bit. And tomorrow, we continue with the same project but with the focus on implementing authentication into the request/response cycle. Authentication. I don’t know enough about it yet to speak with any semblance of authority, but I found the video lectures on the subject to be absolutely fascinating. How cryptographers and other interested parties have tackled the challenges of making sure users are who they say they are, without storing the actual (readable) passwords on their server, while also safeguarding against foul play from the inside… really cool stuff. I especially enjoyed the point about BCrypt in that it rehashes the password many times, and actually displays that number (of rehashes) to any potential attackers as a deterrent from even trying to bruteforce it. And the idea of ‘salting’ the passwords to make up for 'user idiocy’ (highlighted by the [old] study that found that 90% of all passwords comprised of the 1000 most common passwords) is so clever, yet somewhat obvious when you think about it. Absolutely love it, and I cant’ wait to see how we implement it in our own projects tomorrow. What a great way to almost end the week. Unfortunately, due to extenuating circumstances, we have class on Saturday. On the bright side, I’ve found myself somewhat lost on days we’ve had off, so there’s that. Today we continued working on our 99Cats website, but this time with a focus on implementing security measures to protect against a variety of different threats. In general, these measures have been nicely packaged into ‘gems’ that you can implement in a matter of a few keystrokes (slight exaggeration, but not by much). But in good ol’ App Academy fashion, they want us to start building everything from the ground up. We still aren’t allowed to use any of the shortcuts offered by ActiveRecord, nor are we supposed to generate models and controllers in favor of creating them ourselves. I completely respect the reason for this, but I also eagerly await the day we are let of this leash. The hot topic right now is next week’s assessment. It will be the longest assessment we’ve had to date (2 hours), and it is reportedly the hardest of the program. Because of this, it is the week in which the greatest number of students are dismissed due to failing their second assessment. This is something that is really hard for me to accept, as throughout this journey you inevitably develop strong friendships with your peers, yet every Monday threatens to mark the last day in the program for many of us. Fortunately, for now, I do not face dismissal as I’ve passed the three assessments we’ve had so far. Ok, so this is supposed to be more about reflecting on what I’ve learned each day, instead of how I feel. Today I learned a lot about authentication. How cookies are passed between the server and browser; how session keys are set, reset, and deleted; how password information is obscured from (outside) human observation, yet perfectly capable of being 'compared’ against an inputted password via complex hashing functions. We continued to refine our workflow practices in developing a rails project; going back and forth between migrations, models, controllers, and views. We implemented helper methods and partials. We managed validations and constraints. While I consider myself to be less interested in CSS and visuals, my excitement to translate these projects into something more visually impressive is growing. Tomorrow, we will be working on our first real 'app’, and will mark our second solo day. While I’ll miss having a pair partner, it will be nice to finally be able to listen to music again as I code away. I learned a valuable lesson today, but I learned it in the absolute hardest way. Today we were tasked with making a website that stores bands, their albums, and the songs in each album, all the while building and implementing authentication mechanics. Everything was going swimmingly, and it was exciting to finally feel comfortable with authentication. Morning turned afternoon, and we had to take a break from the project to take a practice assessment for next week. This is supposed to be the assessment of all assessments, so for the last 10 minutes leading up to the practice assessment, I was trying to committ as much of the authentication cycle to memory. 1 minute left, and I felt comfortable, but decided that I might as well keep at it as there was nothing better to do until the assessment unlocked. Time was up, and as we were instructed, I deleted everything on the desktop and emptied the trash. Andddd, I forgot to push my project from git. For my parents, git is this really incredible program that allows you to save your projects in ‘snapshots,’ and if you ever bungle your project so badly that you are better off going back to a previous version than spend time trying to undo what you did, Git allows you literally choose from every snapshot that you saved it. The problem, however, is that it is saved locally until you 'push’ it to your online repository, which is what we usually do at the end of the day. Well, my muscle memory hadn’t triggered yet and I forgot to push it. Essentially, two thirds of a day’s worth of work down the drain. Besides that, the practice assessment was rough. I realized my mistake the moment I emptied the trash, so I was somewhat of a headcase. Despite that, I was doing very well for the first hour, until I hit an issue which resulted from my failure to mark one of my methods as a helper method in the ApplicationController file. I didn’t realize it at the time, and the few times I suspected it had to do with the method, I only checked the actual method and not whether I forgot to list it as a helper method. And being compulsive about understanding why something isn’t working, I couldn’t get myself to skip the individual spec. The result was an hour of pretty good progress, and then an entire hour where I didn’t add a single spec to my score. What a way to end the day. I guess the bright side is that there’s no way I’ll ever forget that step again, and I still got above class average, but I was really hoping to start this one day weekend off with my head held high. I guess I’ll have make up for it tomorrow. Today we continued to work on Rails, authentication, et al. In today’s case, we made a Reddit clone. It was a welcomed choice as Reddit is somewhat famous for how basic its design is, and so this was an opportunity for us to apply what we’ve learned in a practical application, without feeling deflated because without any sort of CSS, everything generally looks like crap. Today, it was all about features. My partner and I were able to navigate to the end of the project, leaving only the upvote/downvote system to complete. We implemented a complete authentication process, subreddit creation, moderator status, posts, comments, crossposts (the latter two being intuitively combined into their parent page for integrated access)… Everything was editable/deletable, but only by the user that created it.. It honestly felt like the framework for what could actually be a ‘legit’ app. Perhaps one day I’ll look back to this post and laugh, knowing that there is so much I didn’t know, but I’m still very pleased nonetheless. Especially after the disaster that was last class. Tomorrow, we dive into integration testing. I’m tentatively excited. I really appreciated using RSpecs to guide our ruby projects, but the idea of using RSpecs (or Capybara) to test for 'features’ when you could just play around with your website directly (and you will have to eventually, anyway), sounds a bit unecessary. That and the fact that in some cases, the spec tests are longer than the actual code you would need to write to pass the tests (testing for whether a model validates an attribute is amusing to me, considering how little code you need to type to actually accomplish that). Another thing I bet I’ll change my position on in the coming days, but for now, I’ll keep an open mind. This will be a short post as I’m exhausted. Took the 4th assessment this morning, and did well. Yay! On a sad note, a peer with whom I was getting to know well was among some of the students who not only failed today’s assessment, but failed their second assessment, and as such was dismissed. It is hard to reconcile my belief that this student did not deserve to get kicked out, and in fact is one of the smartest students in the group, with my understanding that App Academy has several legitimate reasons for maintaining a certain standard, and in order to do so, must impose some ‘objective’ system by which they dismiss students who don’t meet that standard. It is simply unfortunate that the 'fairest’ way is through these assessments, and yet these tests are not necessariy accurate models of a real-world working environment; inevitably, students who are perfectly capable of becoming great programmers might simply not perform well on such tests for a variety of reasons. We have now moved on to Javascript. I’m very, very excited for this subject as it is not only one of the most relevant programming languages there is, but it is also a departure from some of the more dry topics we’ve covered over the last few weeks (not including authentication… which I found to be really interesting). We are also beginning to learn CSS, which means my next few web apps might actually look like something I couldn’t draw up in a word processor. First, I can’t believe it has almost been 6 weeks now. While Ruby (the first topic we covered) feels like it was so long ago, the first day feels as if it was yesterday. Interesting how that works. Today was somewhat of a wakeup call. Thus far, I have felt pretty comfortable with the material we’ve covered since the first day of class. We had about a month to build a foundation in Ruby before starting the program, and everything since then has sort of built upon that foundation and the material preceding it. Javascript is a different beast. It not only has syntax unique to it from what we’ve learned, but how it handles data and interacts with browsers – it requires a lot of patience to adjust my expectations in what I can accomplish through this new expressive language that is programming. 4+ weeks ago we were making full-featured chess programs with multiple classes, spread across several files and directories, which could render into a visual representation of a chess board and pieces… today we return to our beginnings and are tasked with the (what no longer sounds easy) job of writing several methods consisting of less than 10 lines of code. Granted, today we tried our hand at recursion again, something that is more difficult to wrap your head around than it is to code once you do, but it still served as a harsh reminder that there is so much more to learn. Tomorrow we continue with javascript, with CSS being sprinkled into our at-home assignments. I am no longer sure whether to be excited by the introduction of CSS, or wary of adding even more to the plate of new subjects. This weekend was spent trying to catch up in JavaScript. It’s a little disheartening to feel ‘behind’ in something that we’ve only spent two days (of classes) on, but Friday was one of the more frustrating days of the program so far, and I would like to endeavor in making sure a repeat doesn’t happen. Friday’s curriculum involved working with callback functions–a technique considered to be essential to functional programming in JavaScript. Essentially, a callback function is one that is passed around as an argument to other functions, waiting to be called but only when the conditions for which it should be called are met. This is typically used for asynchronous functions, which is what allows us to (for example) visit a website, start clicking around, and for things to occur in the background without any noticable hangup. A button, for example, is loaded up and is waiting for us to click on it, and that button (and whatever is to occur when it is clicked) is loaded as soon as the page is loaded. Imagine, then, that something is occuring in the background, the effects of which is important to the user experience. Since JavaScript runs on a single thread (meaning it can do one thing at a time, in exchange for being lightweight), if the button was synchronously programmed, clicking on it would cause whatever was running in the background to suddenly pause while the browser performs whatever it is that happens when you click on the button. Since we use a callback function, and therefore make the button run ansychrononously, the button’s “orders” are essentially loaded up at the beginning, and will be carried out (almost retroactively) upon being clicked on. The analogy that helps me grasp this is thinking of javascript as a commander who is given orders which he must ensure are carried out by the soldiers underneath him. The button is a soldier, and the button is supposed to make a sound whenever clicked on. Without a callback function, the commander would wait until the button is clicked on, upon which he would stop whatever it is he’s doing and tell the button that he must play a sound now that he has been pressed. With a callback function, however, the commander instructs the button in advance what he must do if pressed, so that when that button press occurs, the button already knows what to do without requiring further attention from the commander. It is probable that my understanding of callback functions is (still) flawed, but I do feel a lot more comfortable with the idea than I did on Friday. Today was a good day. After spending the majority of my weekend trying to fill in the gaps of JavaScript and watching several hours of youtube videos on a variety of JavaScript-related subjects, I feel a lot more comfortable now with the language. In particular, I found it most helpful to read about functional programming in JavaScript. My partner and I comfortably progressed through the ‘warm-up’ phase of today’s assignments, and dove into the main project which was to design an Asteroids game. The notable thing about today’s project was that we used Canvas, which is the first time we’ve really had to worry about the graphical output of our programs. This took a while to get used to, but once we correctly set everything up, the logic behind the game was relatively simple: you have a ship, asteroids, and bullets, and any three of these objects are destroyed upon collision with another. The goal of the game, of course, is for the ship to not be among the destroyed. We didn’t get far enough to fully implement control over the ship, but we were able to set the game up with asteroids, moving at random directions and velocities across the screen, wrapping around edges as is customary with the game, and set up collision detection and handling. Overall, it was a big step forward to finally be able to put a 'face’ to our game, as well as the fact that it was the first day in the JavaScript curriculum where I didn’t feel behind. Tomorrow we move on to CSS. After tonight’s homework assignments, my excitement for this topic grows. It is incredible how many different tweaks you can implement through css, creating effects that I would have previously assumed you needed flash (or something similar) for. It is also fascinating to realize how important mobile web browsing has become in the decision making process of web development. We are practically told to build for mobile viewing first, and then adjust for desktop browsing. Amazing. CSS was tougher than I had originally expected. Our task for today was to clone a facebook-esque App Academy social network website, and my partner and I spent the majority of our time finetuning the smallest of details (which was the point of the assignment). Before progressing onto the next phase, a TA would make sure that our version was identical to the target, pixel for pixel. The result of this was we barely made it past the header (that’s an exagerration, but not by much). And true to the saying we’ve heard multiple times, today was 10% coding and 90% debugging. I still have hopes for refining CSS, as I feel generally comfortable with how to interact with a stylesheet, and given enough time I believe I can figure out most problems (if only through a little googling). We also have our capstone projects coming up, which will give us plenty more exposure to the art. But alas, like most of our subjects, our time with them is short, and now we move on to jQuery. jQuery allows us to use JavaScript to control how the user interacts with the browser. It is a very cool JavaScript library, and I’m excited to try it out tomorrow. Besides that, we had our 5th (what was a surprise to me) practice assessment this morning. I did pretty well, missing only the question requiring us to rewrite our own version of Function.prototype.bind, and a few specs of Array.prototype.quicksort because I tried to define the pivot as ‘this.first’ (which is Ruby..) instead of 'this[0]’ (which can be used for both Ruby and JavaScript, so strategically I should be using that no matter what). It was a surprise a got points at all for that problem, except that my function otherwise met the other requirements (like recursively calling itself the correct number of times, using a comparator if passed in, and otherwise using a default comparator). On a fun note, my partner and I rewrote the quicksort method using only 4 lines, while keeping each line within the 80 character line-limit and keeping to proper spacing convention. It also managed to squeeze in a default comparator callback while accepting an optional one from the user. Fun stuff! The world is clear again. After a brief struggle with JavaScript, I feel comfortable with coding again. jQuery sort of brought it all together, allowing us to not only interact with the browser in JavaScript, but providing a vehicle through which we can add/remove/manipulate information on the browser ‘document’, and along with CSS, there are a lot of creative mechanisms to introduce animations/transitions/effects that enhance the user experience. And tomorrow we add ajax to our repertoire, which allows us to inject java into the request/response cycle between the front-end and back-end (the latter, in our case, being rails). I’m sure there are many more implications behind this, but the one that was emphasized in tonight’s readings was that it allows you to make requests to the back-end without having to leave/refresh the current page, resulting in a more seamless user experience, and in many ways a much, much more responsive one. I figuratively can’t wait. On another topic, my partner and I had a great day with today’s projects. We had to make two browser-based games (Tic-Tac-Toe and Towers of Hanoi), using jQuery, javascript, CSS, and a little HTML. It was fun being able to customize the appearance, and manipulate the element tags in order to invoke different CSS styles. We had such a smooth day that we got to the bonus with a good amount of time to spare. This project involved making the classic game of Snake. This time, we were provided with nothing but the rules behind the game, and had to design everything from scratch. We wanted to see if we could complete it with the 45 minutes or so that we had remaining in class, and we were making great progress despite the rush. Then it happened. We didn’t know it at the time, but while we were trying to refine our error and rule handling functions, our browser failed to update some of our new code, resulting in an outdated cache. What that means (if I’ve described it correctly to begin with) is that the browser is attempting to reduce load and redundancy by remembering certain things that it deems to have already been completed. Instead of checking to see whether that something is new/changed, it just invokes whatever it is that it had previously saved. This resulted in really obscure errors, that should have been easy to debug if not for the cache de-sync. We were banging our heads for an hour, trying obscure solutions for every conceivable cause, until we decided to pack it in for the day (now, an hour and a half after class ended). Before finally pushing it to GitHub, I had one more idea I wanted to try. I reopened the browser, and refreshed the page so as to check the error backtrace. Except this time, there was no error! Nothing needed to be fixed, except for a simple two click process of emptying the cache and hard reloading the page. It was an important lesson to learn in debugging, but I can’t say we were too excited to have learnt it that way. Another day, another week. Today marked our first foray into the world of solo programming (outside of the odd day here and there in the past). We begin our capstone projects on Tuesday, and until then we are to complete a ‘mini capstone’ in preparation for that. For the mini capstone, we are working on an AirBnB clone, working with Rails and React, as well as Google Maps API. It was mostly smooth sailing until the very end, when I hit a snag while trying a little test driven development. Well, not exactly, at least as TDD is typically defined, but my general work flow involves frequent console debugging to make sure everything is working how I expect it should before proceeding along. Then, for some reason, 2 lines after defining a variable that would be used in several iterative functions designed to return the coordinates of map markers that I would need in order to render the appropriate results on the page… Chrome’s debugger was telling me that the variabel was not defined. It was literally 2 lines above, defined right there, but instead of calling for help, I assumed that it must have been a strange Reach-related binding issue, and so I tried every which way to get around it. This went on for about an hour before I raised the flag. It turns out that Google Chrome’s debugger will ignore certain variables if it doesn’t see it being used, and so it wasn’t caching the variable I was trying to define. So no matter how many times I tried making sure it was there, I would have had to actually proceed somewhat blindly before being able to confirm that it was working properly. It makes sense, somewhat, but without knowing how Chrome’s debugger worked, there was no way for me to really assume that that was happening (although the simple fact that I was getting undefined for something I knew was being defined should have raised a red flag immediately). Anyway, we have Monday to finish the project, in which we will learn how to implement front-end authentication. I really enjoyed back-end authentication, and I imagine both share similar principles, so I am very excited. On that note, I got my first choice for my Capstone project. I will be cloning Kickstarter, a website that allows users to post project ideas, set a minimum amount of funding required, and other users can pledge an amount to it in exchange for a 'reward’ offered by the creators. Usually, the rewards are simply the product being made, but higher pledges often come with extra bonuses, like signed paraphernalia (I can’t believe I spelt that correctly on my first try!), limited edition versions of said product, etc. A fellow classmate gave me a great idea as to how to add my own touch to the clone, and I’m incredibly excited to make it work: my version will be called “Chronicle ReStarter” and it will essentially be a version of kickstarter for historically significant events as the projects. Examples include the invention of the wheel (and fire), the creation of famous art/literature/movies, etc etc. If I decide it’s not silly enough, I can add 'fictitious’ events involving dinosaur-driven carriages, and so on. The slogan, which is not required but I thought it was funny enough to include in my proposal, is: “The site where you literally reinvent the wheel.” Anyway, I finished my proposal this afternoon, and can be read here. This will be another short post. A friend of mine has invited a guest lecturer, a programmer who works at American Express, which I’ll be attending. As such, my time tonight will be somewhat cramped. Today marks the last day of pair programming. From hereon out, we will be working on our capstones individually. On one hand, I’m excited to be let of the reins, so to speak, but I’ve already experienced in the past how isolating it can feel to program all day without the interaction we’ve grown accustomed to when pairing with others. As for our capstone, I submitted three choices, in the order of: KickStarter, Basecamp, and Evernote. Each of them offer unique opportunities to showcase what I’ve learned. Kickstarter looks like a nice combination of a clean, simple user interface, with a good amount of functionality between submitting ideas to be funded, funding those ideas, along with searching for ideas to check out. Basecamp looks a bit simple on its face, but it offers an opportunity to put a lot of different projects that we’ve done in the past together: to-do lists, messaging/chat, goals, etc. As for Evernote, it is a bit ambitious, but I really appreciate the utility of Evernote, and it has a really slick interface, without being overcomplicated. My preference for Kickstarter over the others is quite strong, but after that, I’m somewhat indifferent between the other two. As for today, my partner and I capped off fling with Flux by making a ‘pokedex,’ a particularly hot topic today in the advent of the pokemon Go craze. I felt that we both had a very strong grasp of Flux (finally!), and I’m excited to continue using it in my capstone. Gonna keep this post short. We have to declare our capstone preferences by tonight, and this is a decision I don’t want to take lightly, considering that it will dictate the next two weeks of my life, and, depending on the impact these have on our future employment prospects, much more than that. If possible, I’m hoping to pick something a bit more complex on the back-end than on the front-end, but it sounds like all of them will involve a heavy dose of front-end development. Today, my partner and I made an app that allowed the user to play music using their keyboard. I expected this project to be a significant step up in terms of difficulty compared to the previous projects, but with the introduction of flux and the buildup from the past few days, I found today to go by incredibly smoothly. As I touched on in the last post, Flux was designed to simplify the callback flow that can become immensely complicated as the app grows large enough. In essence, with Flux, the user interacts with the component on the views page, which informs an actions api when the user does something in particular (like click on a button, type a key.. there are event listeners for pretty much everything), which takes the action and turns it into an object which a ‘dispatcher’ can read, after which it sends it off to every 'store’ contained on your website. In our case, we had a single store that would act differently depending on the contents of the dispatched object. If it was a 'keypress’ object, it would initiate the playing of a certain note, and if it was a 'key release’ object, it would stop the playing of that certain note. Prior to all this, the views page will have sent a listener to the store, essentially telling it that it (the views page, or component) is waiting for a response, and to perform a callback once it receives the relevant object from the dispatcher. Once it does, the store calls the callback, which in our case either played or stopped a particular note. It’s pretty amazing how this all works, and the reason for why it must be done this way, and it definitely instills an immense appreciation on my part for every web-app that I’ve interacted with in the past. Just as we were getting comfortable with React, and the general pattern of setting up the stages of an interactive web app, we now introduce another cog into the development process: Flux. Flux was designed with React in mind (in fact, it was also designed by the Facebook team, and its purpose was to smooth over what can potentially become a very complicated web of stores, listeners, and callbacks), so the transition is somewhat logical, but it is hard to really develop a strong grasp of a subject when we are constantly jumping to another one in but a few days after beginning one. On that note, today my partner and I developed a To-Do list app, building it from the ground up, using Rails as the back-end, and javascript and React for the front-end. We made it to the very end of the project, and had an opportunity to sprinkle in some CSS to make the presentation look a bit less generic. On the whole, I think we developed a pretty good rhythm in setting up React components and subcomponents, passing around state between the component and a ‘store,’ which is the bridge between the front-end and the back-end (it receives orders from the front-end to request information from the back-end, stores that information, and then passes it back to the front-end). And finally, we had to render everything into the browser, which funnily enough is turning out to be a much more complicated process than one might think at first. If you had approached me two months ago and given me an insight into how excited I would get today at merely the display of basic text on an empty document, I wouldn’t have believed you, or if I did, I would have second guessed the reasons to get into programming (“is it really that hard??”). Yet here I am, without any regrets. Another hot topic for the day is we have to decide what to do for our Capstone project, which is a two week project where we must clone a popular website. The clone must be as exact as possible, but we are encouraged to introduce our spin on it (such as a facebook for animals, or an AirBnB for… animals. Animals are a common spin, apparently). I haven’t yet decided what I want to do, but the important factor to consider is how many different 'skills’ will be required to complete the project so that we can showcase how much we’ve learned to potential employers (for which these projects will act as the main component of our portfolio after graduation). It is understandable that employers might be skeptical at the prospect of hiring someone for a full-time position for someonthing as technically demanding as programming, when that person has only been learning it for 3 months, but that is the expectation, and so we must work that much harder to convince them. Today we made a single page website of several ‘widgets’ using React. As I mentioned in my last post, React is a tool developed by Facebook that allows very 'reactive’ interaction with the document. On the whole, the particular widgets we designed are not very interesting (a tab widget, a clock and weather widget, and a auto-complete search widget), but how we made them and how they function without having to reload the page is very interesting. This was especially so for the weather widget, which required us to send a request to another website, wait for a response, and update the page for the user, all without interrupting their browsing. Overall, React is still incredibly new to me, but to only complete 3 small projects in an entire day’s work feels a bit unsettling. On another note, I was inspired by a fellow classmate to make a world simulator over the weekend, and I’m incredibly excited about the results. It’s far from complete, in terms of polish and potential, but already it: 1) Generates multiple countries, varying in size, climate, and 'farmable land’ 2) It then populates each country with 10 males and 10 females of a random race (blue, yellow, green, red) and aged 10 (which, for the purposes of even numbers, is the age which these beings can begin mating and creating offspring). These beings begin with a strength, intelligence, and health attribute, roughly at around 100 each (with slight deviations). 3) Every cycle (of which there are 10 per generation), the weakest 2% of the population is culled off, simulating internal struggle, violence, etc. Everyone also must harvest food, but in the chance of a shortage (based on climate, farmable land, overpopulation, etc), only the strongest (measured by strength and intelligence) eat first, the weakest potentially not eating at all. And finally, as the population grows, disease will spread (especially as available space begins to exhaust), the damage for which is mitigated by overall intelligence of the country along with the inidividual health attribute of each citizen. 4) Every time a new being is born, it will inherit one of its parents’ race, and the average of each parent’s traits, and then modified by a positive or negative amount of 20% (with equal chance). Additionally, only beings of similar 'attractiveness’ will mate together (attractiveness being measured by an aggregation of strength, intelligence, and health). 5) Populations grow as the number of born exceeds the number dying off due to a variety of factors mentioned above, and since the victims are usually the weaker members of society, each country generally trends in an upward direction in terms of its citizens’ average intelligence, strength, and health. 6) While there is no advantage to any particular race, it is fascinating that each country will usually settle with a majority and minority race by the end, with very few, if any, of the other two races. 7) Finally, and by far the most interesting result I’ve observed, is that the countries that won the environmental lottery with a very habitable climate, an abundance of farmable land, etc, usually result in pretty mediocre society in terms of the attributes of its beings, while the countries with hazardous environments resulted in much better developed citizens. This is no doubt because in the countries in which survival is threatened by environmental conditions (struggle for food, fight against disease, fight for a place to live, etc), the strongest prevail and pass on their genes to their offspring. In safe countries, the weak are never tested, and therefore their genes are never really removed from the genepool. This difference is quite pronounced, and shown here (http://i.imgur.com/53DKz9n.png). The first country was unfortunate in being created with a very small amount of farmable land, yet ended up with a much higher average strength/intelligence/health than the second country. On the other hand, the second counry has about three times the population, despite being smaller in size. 8) I could go on about the project, and hope to have more weekends with the same amount of free time that allowed me to experiment with this in the first place, but unfortunately, it seems like this past weekend will be an outlier in the free-time department. In the future, I hope to add random events to test the countries’ ability to adapt to unexpected events (perhaps based on average intelligence), and what I’m most excited to add, is an element of war. As a country begins to run out of space/resources, it will be more likely to seek conflict with another country. I’ve already set the program up to be able to add interactions like this, but it’s just a matter of deciding the exact triggers of war and the resultant scenarios (whether wars will be fought until one side no longer lives; what happens at home of the side that is invading the other.. perhaps since there are less people of working age, that overall food production drops, etc…). Another week down. Technically half way there (although the final 4 weeks are a bit more self-driven, so it feels like we’re a lot closer). To repeat myself for the nth time, time is flying. Friday began with our fifth assessment, which was on JavaScript. Fortunately, it was similar enough to our first assessment on Ruby, which was the assessment I spent by far the most time studying for (at least 20 hours that weekend), so besides having to brush up a bit on some of the more complex recursive functions, I felt generally comfortable going into the assessment, despite not having a weekend to study for it specifically. I had a minor hiccup with having to write my own currying function, but ultimately figured it out and did well on the test. Two more tests to go, meaning that I only have to pass one more to be safe from dismissal, although at this point, and not to sound overconfident, I am less concerned about dismissal as I am with making sure I’m comfortable with all the material going forward. Our project on Friday was to write our own version of jQuery. While many of us found the project to be on the less exciting side of the spectrum, it was useful to both see how jQuery worked behind the scenes, as well as highlight the fact that over time, many of jQuery’s functionality has become standardized, meaning that we can achieve what it was originally designed for using pure JavaScript (its purpose being to allow us to interact with the browser DOM from the JavaScript environment). My partner and I made good progress, making it to the very end of the project by the end of the day. Setting the project up was the tricky part, but once we established a connection with the document to begin with, and developed the pattern to writing the methods by which we can interact with targeted elements, the project became much more straightfoward. Next week, we move on to React, which was developed by Facebook and sounds like it is a much more advanced version of jQuery. It also seems to be the new “hot” library in programming, so it’s very exciting to begin working with it. Besides that, however, I don’t know enough about it to comment much more on it, but hopefully my excitement will prove well-founded in the coming week. This will be short because we have our 5th assessment tomorrow, and today being a thursday (with homework assigned), I don’t have an entire weekend to cram for this one. Today was great. We made a variation of Twitter, using rails, jquery, and ajax. Ajax allows you to manipulate the user’s current browser page without having to refresh the page. Probably the most valuable thing to come out of today is a new-found appreciation for everything that goes on beind the scenes on websites we visit every day. Things that you would expect (as a layperson) to be relatively simple, yet in practice there is an uncountable number of things happening in the background. The google search bar is a good example. As you begin to type out your search, it is auto-completing it with the most popular searches. I took this for granted before, but every time you type a character, the page is sending your search string to Googles servers, which matches it with popular search phrases, and returns it and populates the search bar (with suggested search phrases, without actually changing your text) faster than the time it takes for you to type the next character. All of this in the background without refreshing the page. Incredible. Thoughts aside, my partner and I made great progress today in the assigned project. We spent perhaps a bit too much time tinkering with CSS (to make things look pretty), but we surmounted several tricky obstacles with clever solutions, and the contribution split was very even, which is always nice in a pair programming environment.